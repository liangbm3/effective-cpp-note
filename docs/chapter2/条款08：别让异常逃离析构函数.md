## 条款08：别让异常逃离析构函数

**Prevent exceptions from leaving destructors**

这个条款的核心是，不能让析构函数抛出异常。C++ 并不禁止析构函数抛出异常，但是这个条款强烈不鼓励这样做，因为这可能导致程序崩溃或未定义行为。以下面这个例子为例：

```cpp
class Widget {
public:
    ~Widget() { /* ... 假设这里可能抛出异常 ... */ }
};

void doSomething() {
    std::vector<Widget> v;
    // ... v 中包含 10 个 Widget 对象
} // <--- v 在这里被销毁
```

当 `doSomething()` 函数结束时，局部变量 `v` 会被销毁。`std::vector` 的析构函数会依次调用其包含的每个 `Widget` 对象的析构函数。假设当销毁第 1 个 `Widget` (例如 `v[9]`) 时，它的析构函数 `~Widget()` 抛出了一个异常。此时，C++ 运行时系统开始处理这个异常，这个过程称为栈展开。在栈展开的过程中，C++ 仍然有责任销毁在 `try` 块（即使是隐式的）中已经构造完成的其他对象。它会继续尝试销毁第 2 个 `Widget` (例如 `v[8]`)。如果在销毁第 2 个 `Widget` 时，它的析构函数 `~Widget()` 也抛出了一个异常。C++ 运行时系统无法同时处理两个异常。如果在一个异常尚未被 `catch` 捕获并处理完毕时，又抛出了第二个异常，C++ 会认为情况已经无法挽回。程序会立即调用 `std::terminate()`，默认情况下它会调用 `std::abort()`，导致程序异常终止。

为了不让析构函数抛出异常，文章列举了几种解决方案：

方案 1：在析构函数中终止程序(简单粗暴)：

```cpp
DBConn::~DBConn() {
    try {
        db.close();
    } catch (...) {
        // 制作运转记录，记下 close 的调用失败
        log("Failed to close DB in destructor.");
        // 强行结束程序，阻止异常传播
        std::abort(); 
    }
}
```

如果 `close()` 失败是不可接受的、灾难性的错误，那么直接终止程序是一个合理的选项。

- 优点： 简单，有效防止了双重异常。
- 缺点： 不给用户任何处理错误的机会，程序直接崩溃。

方案 2：在析构函数中吞下异常(隐藏问题)：

```cpp
DBConn::~DBConn() {
    try {
        db.close();
    } catch (...) {
        // 制作运转记录，记下 close 的调用失败
        log("Failed to close DB in destructor.");
        // 吞下异常，什么也不做 (不推荐)
    }
}
```

- 优点： 程序不会崩溃。
- 缺点： 压制了某些动作失败的重要信息。用户完全不知道 `close` 失败了，这可能导致数据未被正确写入、资源泄露等严重后果。

方案 3：分离责任(文章中的最佳实践)：  
为用户提供一个专门的 `close()` 函数，让用户有机会自己处理异常。

```cpp
class DBConn {
public:
    // ... 构造函数等 ...

    // 1. 提供一个供客户手动调用的 close() 函数
    //    这个函数会正常传播异常
    void close() {
        if (!closed) {
            db.close(); // 如果失败，异常会抛给调用者
            closed = true;
        }
    }

    // 2. 析构函数作为“安全网”
    ~DBConn() {
        if (!closed) { // 检查客户是否已经手动调用过 close
            try {
                db.close(); // 仍然尝试关闭
            } catch (...) {
                // 但在这里，必须捕获异常！
                // 选择方案 1 (abort) 或方案 2 (swallow + log)
                // 绝不能让异常离开
                log("DB closed by destructor; failed.");
                // std::abort(); // 或者只是记录日志
            }
        }
    }

private:
    DBConnection db;
    bool closed = false; // 状态标志
};
```

- 优点： 给用户机会处理异常，同时在析构函数中提供了一个安全网，防止资源泄露。

为了强调析构函数不应抛出异常，C++11 做出了一个重要改变：

- 在 C++11 及以后版本中，析构函数默认被标记为 `noexcept(true)`。
- `noexcept(true)` 意味着该函数承诺不会抛出任何异常。
- 如果你在一个 `noexcept(true)` 的函数（如默认的析构函数）中抛出了异常，C++ 运行时系统不会去栈展开，而是会立即调用 `std::terminate()`。

这等于 C++ 语言在语法层面强制执行了这个条款：别让异常逃离析构函数，否则程序就终止。