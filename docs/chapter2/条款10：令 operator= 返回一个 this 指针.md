## 条款10：令 operator= 返回一个 this 指针

**Have assignment operators return a reference to \*this**

这是 C++ 中关于运算符重载的惯例，即为类重载赋值运算符时，应该让它返回一个指向当前对象的引用（`return *this`）。遵循这个惯例能够让我们的自定义类的行为与内置类型和标准库类型保持一致。

这样做的原因是因为在 C 和 C++ 中，内置类型的赋值操作是支持连锁的：
```cpp
int x, y, z;
x = y = z = 15; // 赋值连锁
```

> 右结合律： 赋值运算符是右结合的。C++ 会将上面的代码解析为： `x = ( y = ( z = 15 ) );`

为了让我们的类也支持这种行为：
```cpp
Widget w1, w2, w3;
w1 = w2 = w3; // 我们希望这也合法
```
`w2 = w3` 这个表达式必须返回一个可以被赋给 `w1` 的东西。这个东西最合理的就是被赋值后的 `w2` 本身。

标准的实现如下：
```cpp
class Widget {
public:
    // ...
    // 1. 返回类型是 Widget& (指向当前类的引用)
    Widget& operator=(const Widget& rhs) { 
        // ...
        // (在这里执行实际的赋值逻辑, e.g., 复制 rhs 的数据)
        // ...

        // 2. 返回左侧对象 (即 *this)
        return *this; 
    }
};
```

值得注意的是，这只是一个惯例，C++ 语言本身并不强制必须这样做，如果把 `operator=` 的返回类型定义为 `void`，代码也能编译，但 `w1 = w2 = w3;` 这种连锁赋值就会编译失败。这个惯例不仅适用于 `operator=`，也适用于所有赋值运算符，如果：`+=`、`-=`、`*=`、`/=` 等。