## 条款05：了解 C++ 默认编写并调用了哪些函数
**Know what functions C++ silently writes and calls**

这个条款的核心思想是，如果没有手动声明，C++ 编译器会在需要暗自地为类生成四个特殊的成员函数。对于一个空类，比如 `class Empty {};`，C++ 编译器会将其视为：

```cpp
class Empty {
public:
    Empty();                             // 1. 默认构造函数 (Default Constructor)
    Empty(const Empty& rhs);             // 2. 拷贝构造函数 (Copy Constructor)
    ~Empty();                            // 3. 析构函数 (Destructor)
    Empty& operator=(const Empty& rhs);  // 4. 拷贝赋值运算符 (Copy Assignment Operator)
};
```

- 这些函数默认是 `public` 且 `inline` 的。
- 编译器只在这些函数被调用时（被需要时）才会去生成它们。

编译器生成的拷贝构造函数和拷贝赋值运算符的行为是非常单纯的，指挥逐个成员地对类的 `non-static` 成员变量进行拷贝。

- 对于内置类型（如 `int`, 指针），它们会进行浅拷贝。
- 对于类类型（如 `std::string`），它们会递归地调用该成员的拷贝构造函数或拷贝赋值运算符。

作者在文中强调：编译器并不会总是成功生成 `operator=`。在某些特定情况下，编译器会拒绝为类生成默认的 `operator=`，因为这样做不合法或意图不明。主要有以下三种情况：

- 类中含有引用成员
    - 示例：`std::string& nameValue;`
    - C++ 语法规定，引用必须在创建时初始化，且不能重新指向到另一个不同的对象。编译器生成的 `operator=` 默认行为是逐成员赋值。对于引用成员，它不知道如何处理：让引用 `nameValue` 重新指向 `rhs.nameValue` 在 C++ 语法上不允许，修改 `nameValue` 指向的那个 `string` 对象的内容，使其等于 `rhs.nameValue` 不是 C++ 引用的默认赋值行为。意图不明显且默认行为非法，所以编译器拒绝生成 `operator=`。
- 类中含有 `const` 成员
    - 示例： `const T objectValue;`
    - `const` 成员在对象构造时被初始化后，其值绝对不能再被更改。拷贝赋值的语义就是修改左侧对象的值。如果要逐成员赋值，就必须修改 `const` 成员，这直接违反了 `const` 约束。这是一个明显的矛盾，编译器因此拒绝生成 `operator=`。
- 基类的拷贝赋值运算符是 `private` 的
    - 编译器为派生类生成的 `operator=`，其工作之一就是必须调用其基类的 `operator=`，以便处理属于基类的那部分成员。如果基类的 `operator=` 是 `private` 的，派生类的默认 `operator=` 将没有权限调用它。编译器无法完成它该做的工作，因此拒绝为派生类生成 `operator=`。

对于上面三种情况中的任何一种，如果希望编写的类支持赋值操作，必须手动提供一个自定义的拷贝赋值运算符 `operator=`，以明确指定赋值行为。

文章的内容是基于 C++98 的，在 C++11 引入移动语义后，增加了移动构造函数和移动赋值运算符。对于现代 C++，有著名的三/五/零法则：

- 三法则: (C++98) 如果需要显式定义析构函数、拷贝构造函数或拷贝赋值运算符中的任意一个（通常是因为在类中管理了原始指针等资源），那么很可能需要同时定义这三个。
- 五法则: (C++11) 如果定义了上述三者之一，可能还需要考虑定义移动构造函数和移动赋值运算符。
- 零法则: (最佳实践): 优先使用标准库工具（如 `std::unique_ptr`, `std::shared_ptr`, `std::vector`, `std::string`）来管理资源。这些类已经正确实现了“五大法则”。这样，我们定义的类就可以退化为简单地包含这些成员，而不需要手动编写任何特殊成员函数，编译器将自动生成正确且高效的版本。