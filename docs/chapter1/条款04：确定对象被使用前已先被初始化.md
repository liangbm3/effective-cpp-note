## 条款04：确定对象被使用前已先被初始化

**Make sure that objects are initialized before they're used**

这是 C++ 编程中非常重要的基本原则，因为 C++ 并不保证所有变量在定义时都会被自动初始化：
- 对于内置类型（如 `int`, `double`, 指针）：
  - 在函数体内部定义的（栈上）变量，如果不显式初始化，其值是未定义的（包含"垃圾"值）。
  - 全局变量或 `static` 变量会被初始化为 0。
- 对于类类型（`class` 或 `struct`）：
  - 如果类有默认构造函数，它会被调用。但如果这个默认构造函数没有初始化某些内置类型的成员变量，那些成员变量的值依然是未定义的。

读取一个未初始化的值会导致未定义行为，可能会导致程序崩溃，数据损坏或者看似运行正常但是结果完全错误。

对于类成员的初始化，很多初学者会采用下面这种初始化方式：
```cpp
class ABEntry {
public:
    ABEntry(const std::string& name, const std::string& address, 
            const std::list<PhoneNumber>& phones)
    {
        theName = name;             // 赋值
        theAddress = address;       // 赋值
        thePhones = phones;         // 赋值
        numTimesConsulted = 0;   // 赋值
    }
private:
    std::string theName;
    std::string theAddress;
    std::list<PhoneNumber> thePhones;
    int numTimesConsulted;
};
```

严格意义上讲，这是赋值而非初始化。同时这样做是非常低效的，因为 C++ 规定，在进入构造函数体之前，类的所有成员变量必须已经被初始化。
- 对于 `theName`、`theAddress` 和 `thePhones` 这些类类型，会先调用它们各自的默认构造函数（`std::string()`）来初始化。
- 进入构造函数体后，`=` 运行的是拷贝赋值运算符。
- 总共开销 = 1 次默认构造 + 1 次拷贝赋值。

正确且高效的初始化，应该使用成员初始化列表：
```cpp
class ABEntry {
public:
    ABEntry(const std::string& name, const std::string& address, 
            const std::list<PhoneNumber>& phones)
        : theName(name),           // 调用 std::string 的拷贝构造函数
          theAddress(address),     // 调用 std::string 的拷贝构造函数
          thePhones(phones),       // 调用 std::list 的拷贝构造函数
          numTimesConsulted(0)   // 直接初始化为 0
    {
        // 构造函数体现在为空
    }
private:
    // ... 成员变量同上
};
```

`theName(name)` 这种语法会直接调用 `std::string` 的拷贝构造函数来初始化 `theName`。总共开销 = 1 次拷贝构造。 这显然比默认构造 + 拷贝赋值更高效。对于内置类型（如 `numTimesConsulted`），两者效率可能相同，但保持一致性是一种好习惯。

文中还提到一个重要的常见问题，即成员变量的初始化顺序只与它们在类中声明的顺序有关，而与它们在成员初始化列表中的顺序无关。
```cpp
class MyClass {
public:
    MyClass(int val)
        : j(val), i(j)  // 警告：i 先于 j 被初始化！
    { }
private:
    int i; // i 先声明
    int j; // j 后声明
};
```

文中还提到了一个非局部静态对象的初始化次序问题，非局部静态对象指的是不在函数内部的 `static` 的对象，包括：
- 全局对象
- 定义在 `namespace` 作用域内的对象
- 类中的 `static` 成员对象
- 文件作用域内的 `static` 对象

一个核心的问题是 C++ 只保证同一个编译单元内的非局部静态对象按其定义顺序初始化。但 C++ 不保证跨越不同编译单元的对象之间的初始化顺序。看下面的例子：
假设有两个非局部静态对象，分别在不同的文件：
```cpp
// File_A.cpp
#include "FileSystem.h"
extern FileSystem tfs; // 假设 tfs 是一个重要的全局对象
```

```cpp
// File_B.cpp
#include "Directory.h"
#include "FileSystem.h"

extern FileSystem tfs; // 引用 File_A 中的 tfs

// tempDir 是一个非局部静态对象
Directory tempDir( /* ...一些参数... */ );

// Directory 的构造函数
Directory::Directory( /* ... */ ) {
    // ...
    std::size_t disks = tfs.numDisks(); // 灾难！
}
```

C++ 无法保证 `File_A.cpp` 中的 `tfs` 一定会在 `File_B.cpp` 中的 `tempDir` 之前被初始化。 如果 `tempDir` 先被初始化，它的构造函数就会去调用 `tfs.numDisks()`。但此时 `tfs` 还是一个未初始化的空壳，导致程序崩溃。

这个问题的解决方法是使用局部静态对象，C++ 保证函数内的局部静态对象会在该函数第一次被调用时才被初始化。我们不再定义一个非局部的 `tfs` 对象，而是定义一个函数，让它返回一个局部静态对象的引用：
```cpp
// FileSystem.h (或 .cpp) 中
class FileSystem { /* ... */ };

// 提供一个“访问函数”，取代全局对象
FileSystem& tfs() {
    static FileSystem fs; // 本地静态对象
    return fs;
}
```

```cpp
// Directory.cpp (原 File_B.cpp)
#include "Directory.h"
#include "FileSystem.h" // 包含 tfs() 函数的声明

// tempDir 仍然可以是一个非局部静态对象
Directory tempDir( /* ... */ );

// Directory 的构造函数
Directory::Directory( /* ... */ ) {
    // ...
    // 现在是安全的！
    std::size_t disks = tfs().numDisks(); 
}
```

这个设计模式常被用作单例模式的一种实现，它完美地解决了跨编译单元的初始化顺序问题。

> 在 C++11 之前，上述 `tfs()` 函数的实现是非线程安全的。自 C++11 起，C++ 标准保证本地静态对象的初始化是线程安全的。

总结：
- 对于类成员： 优先且总是使用成员初始化列表来初始化所有成员，确保高效和正确。
- 对于非局部静态对象： 避免它们之间的依赖。如果必须依赖，使用返回局部静态对象引用的函数这一模式来替代直接访问非局部静态对象。